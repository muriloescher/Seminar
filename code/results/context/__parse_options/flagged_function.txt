static struct _light_option *__parse_options(uint32_t **memory, const int32_t max_len)
{
   if (max_len <= 0) {
      return NULL;
   }
   else {
      struct _light_option *opt = calloc(1, sizeof(struct _light_option));
      uint16_t actual_length;
      uint16_t allignment = sizeof(uint32_t);

      uint16_t *local_memory = (uint16_t*)*memory;
      uint16_t remaining_size;

      opt->custom_option_code = *local_memory++;
      opt->option_length = *local_memory++;

      actual_length = (opt->option_length % allignment) == 0 ?
            opt->option_length :
            (opt->option_length / allignment + 1) * allignment;

      if (actual_length > 0) {
         opt->data = calloc(1, actual_length);
         memcpy(opt->data, local_memory, actual_length);
         local_memory += (sizeof(**memory) / sizeof(*local_memory)) * (actual_length / allignment);
      }

      *memory = (uint32_t*)local_memory;
      remaining_size = max_len - actual_length - 2 * sizeof(*local_memory);

      if (opt->custom_option_code == 0) {
         DCHECK_ASSERT(opt->option_length, 0, light_stop);
         DCHECK_ASSERT(remaining_size, 0, light_stop);

         if (remaining_size) {
            // XXX: Treat the remaining data as garbage and discard it form the trace.
            *memory += remaining_size / sizeof(uint32_t);
         }
      }
      else {
         opt->next_option = __parse_options(memory, remaining_size);
      }

      return opt;
   }
}
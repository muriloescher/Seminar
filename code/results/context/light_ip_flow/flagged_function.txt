int light_ip_flow(light_pcapng *sectionp, light_pcapng **flows, size_t *flow_count, size_t *dropped)
{
	light_pcapng section = *sectionp;
	size_t progress = 0;
	size_t limit = light_get_block_count(*sectionp);
	size_t skipped = 0;

	if (__is_section_header(section) == 0) {
		PCAPNG_ERROR("Invalid section header");
		return LIGHT_INVALID_SECTION;
	}

	light_pcapng current_section = section;
	light_pcapng current_interface = NULL;
	light_pcapng *interface_list = NULL;
	uint32_t interface_list_size = 0;

	flow_information_t *current_flow = NULL;
	flow_information_t *last_flow = NULL;
	light_pcapng current_block = section->next_block;

	*flow_count = 0;

	while (current_block != NULL) {
		uint32_t type = current_block->block_type;
		if (type == LIGHT_SECTION_HEADER_BLOCK) {
			// current_section = current_block;
			*sectionp = current_block;
			break;
		}
		else if (type == LIGHT_INTERFACE_BLOCK) {
			current_interface = current_block;
			interface_list = realloc(interface_list, (interface_list_size + 1) * sizeof(light_pcapng));
			interface_list[interface_list_size] = current_interface;
			interface_list_size++;
		}
		else if (type == LIGHT_ENHANCED_PACKET_BLOCK || type == LIGHT_SIMPLE_PACKET_BLOCK) {
			flow_address_t flow_key = {0};
			uint8_t protocol_version;
			flow_information_t *match = NULL;

			if (__get_address(current_block, &flow_key, &protocol_version) == LIGHT_FALSE) {
				skipped++;
				goto iterate;
			}

			if (current_flow == NULL) { // Beginning of the trace.
				if (type == LIGHT_SIMPLE_PACKET_BLOCK) {
					current_flow = __create_flow(current_section, current_interface, &flow_key, protocol_version);
				}
				else {
					struct _light_enhanced_packet_block *epb = (struct _light_enhanced_packet_block *)current_block->block_body;
					current_flow = __create_flow(current_section, interface_list[epb->interface_id], &flow_key, protocol_version);
				}
				match = current_flow;
				last_flow = current_flow;
				*flow_count = 1;
			}
			else {
				match = __find_flow(current_flow, &flow_key, protocol_version);
			}

			if (match == NULL) {
				if (type == LIGHT_SIMPLE_PACKET_BLOCK) {
					match = __create_flow(current_section, current_interface, &flow_key, protocol_version);
				}
				else {
					struct _light_enhanced_packet_block *epb = (struct _light_enhanced_packet_block *)current_block->block_body;
					match = __create_flow(current_section, interface_list[epb->interface_id], &flow_key, protocol_version);
				}

				last_flow->next = match;
				last_flow = match;
				*flow_count += 1;
			}
			else {
				match->last_block->next_block = __copy_block(current_block, LIGHT_FALSE);
				match->last_block = match->last_block->next_block;
			}
		}
		else {
			// TODO: Append other blocks to all flows accordingly.
		}

iterate:
		progress++;
		if (progress % 10000 == 0) {
			printf("Flow extraction progress: %.2lf [%d / %d]\n", (double)progress / limit * 100.0, (int)progress, (int)limit);
		}
		current_block = current_block->next_block;
	}

	if (dropped != NULL) {
		*dropped = skipped;
	}

	// End of trace.
	if (current_block == NULL) {
		*sectionp = NULL;
	}

	*flows = calloc(*flow_count, sizeof(light_pcapng));
	uint32_t index = 0;
	flow_information_t *iterator = current_flow;

	while (iterator != NULL) {
		(*flows)[index] = iterator->section;
		__validate_section((*flows)[index]);
		__append_address_information(iterator->section, iterator);
		index++;
		iterator = iterator->next;
	}

	while (current_flow != NULL) {
		flow_information_t *to_be_deleted = current_flow;
		current_flow = current_flow->next;
		free(to_be_deleted);
	}

	free(interface_list);

	return LIGHT_SUCCESS;
}
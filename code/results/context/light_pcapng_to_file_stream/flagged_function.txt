size_t light_pcapng_to_file_stream(const light_pcapng pcapng, light_file file)
{
   light_pcapng iterator = pcapng;
   uint32_t *block_mem = NULL;
   uint32_t block_size = 0;

   size_t total_bytes = 0;
   while (iterator != NULL)
   {
      if (block_size < iterator->block_total_length)
      {
         //TODO this block of memory could be kept with the file and re-used as the reconstruction buffer
         //Until the output file is actually closed
         block_mem = realloc(block_mem, iterator->block_total_length);
         block_size = iterator->block_total_length;
      }
      DCHECK_NULLP(block_mem, return 0);
      size_t body_length = iterator->block_total_length - 2 * sizeof(iterator->block_total_length) - sizeof(iterator->block_type);
      size_t option_length;
      uint32_t *option_mem = __get_option_size(iterator->options, &option_length);
      body_length -= option_length;

      block_mem[0] = iterator->block_type;
      block_mem[1] = iterator->block_total_length;
      memcpy(&block_mem[2], iterator->block_body, body_length);
      memcpy(&block_mem[2 + body_length / 4], option_mem, option_length);
      block_mem[iterator->block_total_length / 4 - 1] = iterator->block_total_length;

      DCHECK_ASSERT(iterator->block_total_length, body_length + option_length + 3 * sizeof(uint32_t), light_stop);

      free(option_mem);
      total_bytes += iterator->block_total_length;
      light_write(file, block_mem, iterator->block_total_length);
      iterator = iterator->next_block;
   }

   free(block_mem);

   return total_bytes;
}
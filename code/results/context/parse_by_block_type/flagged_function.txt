void parse_by_block_type(struct _light_pcapng *current, const uint32_t *local_data, const uint32_t *block_start)
{
   switch (current->block_type)
   {
      case LIGHT_SECTION_HEADER_BLOCK:
      {
         DPRINT_HERE(LIGHT_SECTION_HEADER_BLOCK);
         struct _light_section_header *shb = calloc(1, sizeof(struct _light_section_header));
         struct _light_option *opt = NULL;
         uint32_t version;
         int32_t local_offset;

         shb->byteorder_magic = *local_data++;
         // TODO check byte order.
         version = *local_data++;
         shb->major_version = version & 0xFFFF;
         shb->minor_version = (version >> 16) & 0xFFFF;
         shb->section_length = *((uint64_t*)local_data);
         local_data += 2;

         current->block_body = (uint32_t*)shb;
         local_offset = (size_t)local_data - (size_t)block_start;
         opt = __parse_options((uint32_t **)&local_data, current->block_total_length - local_offset - sizeof(current->block_total_length));
         current->options = opt;
      }
      break;

      case LIGHT_INTERFACE_BLOCK:
      {
         DPRINT_HERE(LIGHT_INTERFACE_BLOCK);
         struct _light_interface_description_block *idb = calloc(1, sizeof(struct _light_interface_description_block));
         struct _light_option *opt = NULL;
         uint32_t link_reserved = *local_data++;
         int32_t local_offset;

         idb->link_type = link_reserved & 0xFFFF;
         idb->reserved = (link_reserved >> 16) & 0xFFFF;
         idb->snapshot_length = *local_data++;
         current->block_body = (uint32_t*)idb;
         local_offset = (size_t)local_data - (size_t)block_start;
         opt = __parse_options((uint32_t **)&local_data, current->block_total_length - local_offset - sizeof(current->block_total_length));
         current->options = opt;
      }
      break;

      case LIGHT_ENHANCED_PACKET_BLOCK:
      {
         DPRINT_HERE(LIGHT_ENHANCED_PACKET_BLOCK);
         struct _light_enhanced_packet_block *epb = NULL;
         struct _light_option *opt = NULL;
         uint32_t interface_id = *local_data++;
         uint32_t timestamp_high = *local_data++;
         uint32_t timestamp_low = *local_data++;
         uint32_t captured_packet_length = *local_data++;
         uint32_t original_packet_length = *local_data++;
         int32_t local_offset;
         uint32_t actual_len = 0;

         PADD32(captured_packet_length, &actual_len);

         epb = calloc(1, sizeof(struct _light_enhanced_packet_block) + actual_len);
         epb->interface_id = interface_id;
         epb->timestamp_high = timestamp_high;
         epb->timestamp_low = timestamp_low;
         epb->capture_packet_length = captured_packet_length;
         epb->original_capture_length = original_packet_length;

         memcpy(epb->packet_data, local_data, captured_packet_length); // Maybe actual_len?
         local_data += actual_len / sizeof(uint32_t);
         current->block_body = (uint32_t*)epb;
         local_offset = (size_t)local_data - (size_t)block_start;
         opt = __parse_options((uint32_t **)&local_data, current->block_total_length - local_offset - sizeof(current->block_total_length));
         current->options = opt;
      }
      break;

      case LIGHT_SIMPLE_PACKET_BLOCK:
      {
         DPRINT_HERE(LIGHT_SIMPLE_PACKET_BLOCK);
         struct _light_simple_packet_block *spb = NULL;
         uint32_t original_packet_length = *local_data++;
         uint32_t actual_len = current->block_total_length - 2 * sizeof(current->block_total_length) - sizeof(current->block_type) - sizeof(original_packet_length);

         spb = calloc(1, sizeof(struct _light_enhanced_packet_block) + actual_len);
         spb->original_packet_length = original_packet_length;

         memcpy(spb->packet_data, local_data, actual_len);
         local_data += actual_len / sizeof(uint32_t);
         current->block_body = (uint32_t*)spb;
         current->options = NULL; // No options defined by the standard for this block type.
      }
      break;

      case LIGHT_CUSTOM_DATA_BLOCK:
      {
         DPRINT_HERE(LIGHT_CUSTOM_DATA_BLOCK);
         struct _light_custom_nonstandard_block *cnb = NULL;
         struct _light_option *opt = NULL;
         uint32_t len = *local_data++;
         uint32_t reserved0 = *local_data++;
         uint32_t reserved1 = *local_data++;
         int32_t local_offset;
         uint32_t actual_len = 0;

         PADD32(len, &actual_len);
         cnb = calloc(1, sizeof(struct _light_custom_nonstandard_block) + actual_len);
         cnb->data_length = len;
         cnb->reserved0 = reserved0;
         cnb->reserved1 = reserved1;

         memcpy(cnb->packet_data, local_data, len); // Maybe actual_len?
         local_data += actual_len / sizeof(uint32_t);
         current->block_body = (uint32_t*)cnb;
         local_offset = (size_t)local_data - (size_t)block_start;
         opt = __parse_options((uint32_t **)&local_data, current->block_total_length - local_offset - sizeof(current->block_total_length));
         current->options = opt;
      }
      break;

      default: // Could not find registered block type. Copying data as RAW.
      {
         DPRINT_HERE(default);
         uint32_t raw_size = current->block_total_length - 2 * sizeof(current->block_total_length) - sizeof(current->block_type);
         if (raw_size > 0)
         {
            current->block_body = calloc(raw_size, 1);
            memcpy(current->block_body, local_data, raw_size);
            local_data += raw_size / (sizeof(*local_data));
         }
         else
         {
            current->block_body = NULL;
         }
      }
      break;
   }
}